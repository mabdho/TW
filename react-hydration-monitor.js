#!/usr/bin/env node
import t from"puppeteer"
import e from"fs"
import s from"path"
class i{constructor(){this.hydrationIssues=[],this.consoleMessages=[],this.browser=null,this.page=null}async initialize(){void 0,this.browser=await t.launch({headless:!0,args:["--no-sandbox","--disable-setuid-sandbox"]}),this.page=await this.browser.newPage(),this.page.on("console",t=>{const e=t.text()
this.consoleMessages.push({type:t.type(),message:e,timestamp:(new Date).toISOString()}),this.isHydrationWarning(e)&&this.hydrationIssues.push({type:"hydration_warning",message:e,timestamp:(new Date).toISOString(),severity:this.getWarningSeverity(e)})}),this.page.on("pageerror",t=>{(t.message.includes("hydrat")||t.message.includes("server")||t.message.includes("client"))&&this.hydrationIssues.push({type:"hydration_error",message:t.message,stack:t.stack,timestamp:(new Date).toISOString(),severity:"critical"})})}isHydrationWarning(t){return[/Warning.*Text content did not match/i,/Warning.*Prop.*did not match/i,/Warning.*Expected server HTML/i,/Hydration failed/i,/server.*client.*mismatch/i,/Warning.*validateDOMNesting/i,/Warning.*Extra attributes from the server/i,/Warning.*Missing attributes from the server/i].some(e=>e.test(t))}getWarningSeverity(t){return t.includes("Hydration failed")||t.includes("critical")?"critical":t.includes("Text content did not match")||t.includes("Prop")?"high":t.includes("Extra attributes")||t.includes("Missing attributes")?"medium":"low"}async testPage(t,e){void 0
try{const s=this.hydrationIssues.length
await this.page.goto(t,{waitUntil:"networkidle0",timeout:3e4}),await this.page.waitForTimeout(2e3)
const i=await this.page.evaluate(()=>window.React&&document.querySelector("#root")&&document.querySelector("#root").innerHTML.length>100)
i||this.hydrationIssues.push({type:"hydration_timeout",message:`Hydration did not complete within timeout for ${e}`,page:e,url:t,timestamp:(new Date).toISOString(),severity:"critical"})
const o=this.hydrationIssues.length-s
return 0===o,void 0,{page:e,url:t,issues:o,hydrationComplete:i}}catch(s){return void 0,this.hydrationIssues.push({type:"test_error",message:`Failed to test ${e}: ${s.message}`,page:e,url:t,timestamp:(new Date).toISOString(),severity:"critical"}),{page:e,url:t,issues:1,hydrationComplete:!1,error:s.message}}}async testAllPages(){void 0
const t=[{name:"Home Page",url:"http://localhost:5000/"},{name:"Destinations Page",url:"http://localhost:5000/destinations"},{name:"Blogs Page",url:"http://localhost:5000/blogs"},{name:"London City Page",url:"http://localhost:5000/best-things-to-do-in-london"},{name:"Rome City Page",url:"http://localhost:5000/best-things-to-do-in-rome"},{name:"Privacy Policy",url:"http://localhost:5000/privacy-policy"},{name:"Terms of Service",url:"http://localhost:5000/terms-of-service"},{name:"Cookie Policy",url:"http://localhost:5000/cookie-policy"}],e=[]
for(const s of t){const t=await this.testPage(s.url,s.name)
e.push(t)}return e}analyzeIssues(){if(void 0,0===this.hydrationIssues.length)return void 0,{status:"perfect",issues:[]}
const t={},e={critical:0,high:0,medium:0,low:0}
return this.hydrationIssues.forEach(s=>{t[s.type]||(t[s.type]=[]),t[s.type].push(s),e[s.severity]++}),this.provideFixes(t),{status:e.critical>0?"critical":"issues_found",totalIssues:this.hydrationIssues.length,breakdown:e,issues:this.hydrationIssues}}provideFixes(t){void 0,t.hydration_warning&&(void 0,t.hydration_warning.forEach(t=>{t.message.includes("Text content did not match"),0})),t.hydration_error&&(void 0,t.hydration_error.forEach(t=>{void 0})),t.hydration_timeout&&(void 0,t.hydration_timeout.forEach(t=>{void 0}))}generateReport(){const t={timestamp:(new Date).toISOString(),summary:{totalIssues:this.hydrationIssues.length,totalConsoleMessages:this.consoleMessages.length},issues:this.hydrationIssues,consoleMessages:this.consoleMessages.filter(t=>"warning"===t.type||"error"===t.type)}
return e.writeFileSync("hydration-monitoring-report.json",JSON.stringify(t,null,2)),t}async cleanup(){this.browser&&await this.browser.close()}}process.on("SIGINT",async()=>{void 0,process.exit(0)}),process.on("uncaughtException",t=>{void 0,process.exit(1)}),import.meta.url===`file://${process.argv[1]}`&&async function(){const t=new i
try{await t.initialize(),await t.testAllPages()
const e=t.analyzeIssues()
t.generateReport(),void 0,e.status}catch(e){void 0}finally{await t.cleanup()}}()
export{i as ReactHydrationMonitor}
